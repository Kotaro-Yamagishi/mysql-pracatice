# mysql-pracatice
#### ストレージエンジン
データの保存方法や管理方法を決める仕組み
テーブルの裏側で「どんな仕組みでデータが保存され、検索・更新されるか」を決めるもの
ストレージエンジンはサーバーとストレージエンジンAPIを通じてやりとりされる。これにより、ストレージエンジン間の違いがなくなり、Adapterのような役割を果たす

#### ストアドプロシージャ
「あらかじめ定義しておいた一連のSQL文のかたまり」
MySQLサーバーの中に保存されていて、必要なときに名前を指定して呼び出して使う
ユースケースは以下
- 同じ処理を何度も使いたい
- 複雑な処理をまとめたい
- 一部の処理を隠したい（カプセル化）
- パフォーマンスを良くしたい（ネットワーク通信の回数を減らせる）

#### クライアント接続
ユーザーがMySQLサーバーにアクセスして操作を行うこと
それぞれのサーバープロセス内で独自のスレッドを取得する
接続のクエリはその1つのスレッドで実行され、そのスレッドは1つのコアまたはCPUに関連づけられる
また、サーバーはこのスレッドをキャッシュするため、新しい接続のたびにスレッドの作成と削除を繰り返す必要はない

#### 内部構造（解析ツリー）の作成
MySQLがSQL文（クエリ）を理解し、実行できる形に変換する一連の処理のこと

| フェーズ                 | 内容                                 |
| ------------------------ | ------------------------------------ |
| パーシング               | クエリを構文として解釈し構文木を作る |
| 最適化（オプティマイザ） | 最も効率の良い方法を検討する         |
| 実行計画の作成           | 実行の手順（内部構造）を組み立てる   |
| 実行                     | 実際にデータベースが処理を行う       |

#### オプティマイザ
MySQLがクエリを受け取った後に 「最も効率の良い実行計画」 を決める仕組み
```
EXPLAIN SELECT * FROM users WHERE age > 20;
```
このコマンドを使えば、実行計画を見ることができる
以下は例
- 使用されたインデックス
- 行数の見積もり
- 結合方法
- 処理順序

#### 並行性の制御
複数のトランザクションが同時に動いても、データの整合性や正しさを守るための仕組み
常にリソースへの書き込みを行うクライアントを1つだけにし、クライアントの書き込み中は全てのより見取りを阻止するのが勇逸安全なポリシー
ロックがリソースを消費する
ロックの取得、ロックが空いてるかどうかのチェック、ロックの解除を含め、どのロック操作にもオーバーヘッドが伴う

#### オーバーヘッド
本来の目的以外にかかる余分なコストや処理のこと
DB関連だと以下のような場合、オーバーヘッドが発生しやすい
テーブルロック → 行ロックより簡単だが、他の人を全部待たせる → 並列性が悪化
複雑なクエリ → JOINが多い、サブクエリが深い → CPU・メモリのオーバーヘッドが大きくなる

#### ロック戦略
ロックのオーバーヘッドとデータの安全性に折り合いをつけることであり、どのように折り合いをつけるかがパフォーマンスを左右する。
MySQLのストレージエンジンは、独自のロックポリシーとロック粒度を実装可能

#### テーブルロック
テーブル単位でアクセスを制限するロックのこと
テーブルに対して読み書き自由、他の人は users テーブルに対して何もできない（読みも書きも不可）
オーバーヘッドは低い

#### 行ロック
テーブル全体ではなく、1行ごとにロックをかける仕組みのこと
オーバーヘッドが高い

#### トランザクション
複数の処理を1つのまとまりとして扱い、「全部成功するか、全部失敗するか」を保証する仕組み

#### ACIDテスト
| 性質       | もう少し詳しく                             | 例                                                   |
| ---------- | ------------------------------------------ | ---------------------------------------------------- |
| 原子性 (A) | 処理は全部成功か全部失敗のどちらか         | 途中でエラーが起きたら、すべての変更を戻す           |
| 一貫性 (C) | トランザクション開始前後で整合性が保たれる | 口座残高がマイナスにならない、IDが重複しないなど     |
| 独立性 (I) | 他のトランザクションの中間状態は見えない   | 他のトランザクションの途中の変更を読めない           |
| 永続性 (D) | コミットしたら変更は永遠に保存される       | システムクラッシュ後もコミット済みデータは失われない |

#### ダーティリード
まだ確定（COMMIT）されていない他人の変更内容を読んでしまうこと
READ UNCOMMITTED	


#### ノンリピータブルリード
**同じ行**を2回読んで**値が変わる**
同じクエリを1つのトランザクション内で2回実行したとき、結果が変わってしまう現象
トランザクションAは一貫した状態で処理したいのに、途中で他の人に書き換えられてしまう
データの一貫性が崩れるリスクがある

#### ファントムリード
**WHERE条件に一致する行の集合が変わる**
同じ検索条件で2回クエリを実行したとき、結果に「新しい行が増えたり減ったり」する現象
例）トランザクションAが同じ検索条件で2回クエリを実行した際、間にトランザクションBが該当条件に一致する新しい行を追加・コミットしたため、2回目の結果に最初は存在しなかった行が現れる現象をファントムリードという。

#### デッドロック
複数のトランザクションが互いに相手のロックを待ち続けることで、処理が停止する状態

#### トラインザクションログ
ディスク上で管理されるため、永続性あり

#### InnoDB
安定・高性能なトランザクション管理	
特徴：
- トランザクション対応（ACID）
- 行ロックによる高い並行性能
- クラッシュリカバリ機能あり
- 外部キー制約をサポート

#### NDB Cluster
分散型ストレージエンジン
高可用性・冗長構成・分散データ処理
特徴：
- データを複数ノードに自動分散・冗長化
- 高可用性（1台障害でも動き続ける）
- メモリベース処理中心で高速（ただし制約あり）
- リアルタイム性や自動フェイルオーバー重視

#### ASNI規格の4つの分離レベル
| 分離レベル              | 主な特徴                                                 | 発生しうる現象                                           |
| ----------------------- | -------------------------------------------------------- | -------------------------------------------------------- |
| **1. READ UNCOMMITTED** | 他の未確定な変更（未コミット）も読める                   | ダーティリード、ノンリピータブルリード、ファントムリード |
| **2. READ COMMITTED**   | コミット済みの変更のみ読める                             | ノンリピータブルリード、ファントムリード                 |
| **3. REPEATABLE READ**  | 同じ行の読み取り結果が常に同じ（ロック保持）             | ファントムリード（MySQLでは発生する）                    |
| **4. SERIALIZABLE**     | すべてのトランザクションが**直列化されたかのように実行** | すべての現象を防止できる                                 |

#### Lock Tables
明示的にロックをかけるSQL文

#### MVCC（Multi-Version Concurrency Control：多版同時実行制御）
各トランザクションが同時に処理しても互いに干渉しないよう、データの「スナップショット（過去バージョン）」を使って整合性を保つ仕組み
MySQL（特にInnoDB）で使われている高性能な並行処理制御の仕組み
**MVCCには標準的な動作というものがないので把握することが大事**
ある時点で存在していたデータのスナップショットを作成するという仕組みで動作する

#### 楽観的並行性制御
「他と競合しないだろう」と仮定して処理し、後から矛盾を検出して対処する方法

#### 悲観的並行性制御
「他と競合するかもしれない」と仮定して、最初にロックして衝突を防ぐ方法

#### プラグイン
MySQL本体に機能を後から追加できる仕組みで、必要な機能だけを読み込んで使えるモジュールのこと

#### クラスタ化インデックス
クラスタ化インデックスとは、テーブルのデータ自体がインデックスの構造に組み込まれており、主キー順に物理的に並んでいるインデックスのこと
主キー検索が非常に速い、範囲検索に強い
主キーが長いと重い、副インデックスからのアクセスが遅くなる

#### 適応ハッシュインデックス
InnoDBが頻繁に使われるクエリパターンを検出して、自動的にハッシュインデックスを作成し、アクセスを高速化する機能
メモリ上にハッシュとしてよく使われるクエリを保持

#### 挿入バッファ
副インデックスへの挿入操作を一時的にメモリにバッファリングしておき、後でまとめてディスクに書き込むことでI/Oコストを減らす仕組み

#### MyISAMエンジン
トランザクションまたは行ロックをサポートしていない、クラッシュセーフもない
読み取り専用である場合やテーブルがそれほど大きくない場合はよいが、基本的にはInnoDBが採用される

##### ストレージ
MyISAMはデータファイルとインデックスファイルの二つのファイルに保存する
テーブルに収納できる行の数は主にデータベースサーバー上のディスクの空き領域とOSで作成可能なファイルの最大サイズによって制限

##### MyISAMの機能
ロックと並行性：テーブル全体をロック
リペア：手動および自動でサポートしているが、トランザクションやクラッシュリカバリと混同しないように注意
インデックス機能：全文インデックスをサポート

#### 遅延キー書き込み
インデックス（キー）情報のディスクへの書き込みを遅らせて、バッファに一時保持し、まとめて書き込む方式のこと

#### 全文インデックス
自然文の中から特定の単語やフレーズを効率的に検索できるようにするインデックス

#### バッファ
一時的にデータを保存するメモリ領域のこと。ディスクへの読み書きを効率化するために使われる

#### ミューテックス
同時に複数の処理が特定の資源（メモリやファイルなど）にアクセスしないように制御するためのロック機構のこと
「一度に1つのスレッドだけが処理できるようにする仕組み」

#### 列志向と行志向
| 特徴     | 行志向                  | 列志向                           |
| -------- | ----------------------- | -------------------------------- |
| 保存形式 | レコード単位（1行ずつ） | 列単位（1列ずつ）                |
| 強い処理 | OLTP（更新・検索）      | OLAP（集計・分析）               |
| 例       | InnoDB, MyISAM          | MySQLには原則非対応（外部製品）  |
| 備考     | 汎用性が高い            | カラムナDB（ClickHouse等）が得意 |

#### ブロック
ディスクやメモリでデータを読み書きする最小のまとまり  
ディスクは「バイト単位」ではなく「ブロック単位」で読み書きする  
よって、必要なデータより多く読み込むこともある  

#### クラッシュリカバリ
##### クラッシュ
MySQLサーバーやホストマシンが予期せず停止したり、強制終了したりすること
- サーバーの電源断
- OSのクラッシュや再起動
- MySQLプロセスの異常終了
- ハードウェア障害やディスク障害
##### リカバリ
サーバー再起動後にクラッシュ前の一貫性のある状態にデータベースを復旧する処理のこと
InnoDBストレージエンジンの**トランザクションログ（リカバリログやREDOログ）**を使い、
コミット済みのトランザクションを反映（redo）
未コミットのトランザクションを取り消し（undo）
することで、データの整合性を保つ

#### 圧縮テーブル
MySQLのストレージエンジン（主にInnoDB）で扱うデータをディスク上で圧縮して保存するテーブルのこと
圧縮されているためディスク容量の削減やIOの減少が望めるが、圧縮・解答時にCPU負荷がかかるため、CPUリソースとのバランスが大事

#### 読み取りロック
読み取り中にデータを他のトランザクションから書き換えられないようにするロック
複数のトランザクションが同時に読み取りロックを取得できる（共有できる）
しかし、読み取りロック中は書き込みロック（排他ロック）は取得できない

#### 書き込みロック
書き込み（更新・削除・挿入）する際に取得するロック
書き込みロックを持つと、そのデータは他のトランザクションから読み取りも書き込みもできなくなる
書き込みロックは基本的に1つしか保持できない（排他）

#### バイナリディストリビューション
ソフトウェアの完成した実行ファイル（バイナリ形式）を配布する形態のこと

#### ソースディストリビューション
ソフトウェアのソースコードを配布し、利用者が自分でコンパイルしてインストールする形態

#### バイナリプロトコル
MySQLクライアントとサーバー間で使われる通信プロトコルの一つ
テキストプロトコルに比べてデータのやりとりが効率的で高速
特に**プリペアドステートメント（Prepared Statement）**で使われることが多い
データのサイズが小さくなり、解析や送受信のコストが低減される

#### パーティショニング
大きなテーブルを複数の小さな部分（パーティション）に分割して管理する機能・仕組みのこと

#### レプリケーション
データベースの内容を別のサーバー（スレーブ）に複製する仕組み
用途：障害対策（冗長化）、読み込み負荷分散、バックアップ

#### 半同期レプリケーション
マスターでの更新がスレーブに少なくとも1台書き込まれたことを確認してからコミットを完了する方式
これにより、完全同期（すべてのスレーブが反映完了まで待つ）より遅延は小さく、非同期よりもデータの一貫性が高い

#### データセット
ある目的のために集められたデータの集合体のこと
SQLでの意味：クエリで取得した結果の行の集合

#### CPUバウンド状態
プログラムや処理の実行が「CPUの処理能力の限界」によってボトルネックになる状態

#### I/Oバウンド
入出力（ディスクアクセスやネットワーク通信）が遅くて処理が制約される状態

#### ベンチマーク
システムやソフトウェア、ハードウェアなどの「性能（スピードや処理能力）」を数値で測定・比較するためのテストやその結果のこと

#### フルスタックベンチマーク
アプリ全体（フロント〜DBまで）を通した性能測定

#### 単一コンポーネントベンチマーク
個別の要素（DB、API など）に限定した詳細な性能測定


#### スループット
単位時間あたりに処理できる仕事量やデータ量を表す性能指標
時間単位あたりのトランザクションの数として定義

#### 応答時間（Response Time） / 遅延（Latency）
1つのリクエストに対して、最初から最後までにかかった時間

#### 並行性（Concurrency
「同時に進行している処理の数」や「同時接続数」

#### スケーラビリティ
「負荷が増えたときに、どれだけ性能を保てるか（または拡張できるか）」

#### パーセンタイル実行時間
「全リクエストのうち、◯%はこの時間以内に処理された」ことを示す値
なぜこれを利用する？
平均応答時間は、極端に遅いリクエストがあると大きくズレてしまう
パーセンタイルは「どれだけのユーザーが快適に使えているか」を示す
p95 や p99 は SLA（サービス品質保証）やパフォーマンス評価によく使われる

#### ホットスポット
データベースやアプリケーションで、一部のリソースにアクセスが集中し、性能劣化やボトルネックの原因になる箇所
例）DB、キャッシュ、分散システム
スケーラビリティの低下
ロックの増加→遅延やタイムアウト
均等にリソースを使えないため、性能に頭打ち

#### システムのウォームアップ
本番稼働やベンチマーク実行の前に、システムをある程度“温めて”から本処理を開始すること
例えば、DBシステムのウォームアップだと、アプリ起動直後はクエリを投げても遅い（キャッシュが空、最適化されていない）が、何百件か投げているとバッファプールが溜まってきて高速になる
ウォームアップの例
| システム種類    | ウォームアップ内容                      |
| --------- | ------------------------------ |
| データベース    | バッファプールにデータを読み込んでおく            |
| Javaアプリ   | JITコンパイルが最適化されるまで処理を流す         |
| Webサーバー   | 初期リクエストでTLS・ミドルウェア初期化          |
| キャッシュシステム | 主要キーを事前に Memcached や Redis に投入 |

