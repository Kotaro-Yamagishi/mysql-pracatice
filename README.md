# mysql-pracatice
#### ストレージエンジン
データの保存方法や管理方法を決める仕組み
テーブルの裏側で「どんな仕組みでデータが保存され、検索・更新されるか」を決めるもの
ストレージエンジンはサーバーとストレージエンジンAPIを通じてやりとりされる。これにより、ストレージエンジン間の違いがなくなり、Adapterのような役割を果たす

#### ストアドプロシージャ
「あらかじめ定義しておいた一連のSQL文のかたまり」
MySQLサーバーの中に保存されていて、必要なときに名前を指定して呼び出して使う
ユースケースは以下
- 同じ処理を何度も使いたい
- 複雑な処理をまとめたい
- 一部の処理を隠したい（カプセル化）
- パフォーマンスを良くしたい（ネットワーク通信の回数を減らせる）

#### クライアント接続
ユーザーがMySQLサーバーにアクセスして操作を行うこと
それぞれのサーバープロセス内で独自のスレッドを取得する
接続のクエリはその1つのスレッドで実行され、そのスレッドは1つのコアまたはCPUに関連づけられる
また、サーバーはこのスレッドをキャッシュするため、新しい接続のたびにスレッドの作成と削除を繰り返す必要はない

#### 内部構造（解析ツリー）の作成
MySQLがSQL文（クエリ）を理解し、実行できる形に変換する一連の処理のこと

| フェーズ    | 内容                 |
| ------- | ------------------ |
| パーシング   | クエリを構文として解釈し構文木を作る |
| 最適化（オプティマイザ）     | 最も効率の良い方法を検討する     |
| 実行計画の作成 | 実行の手順（内部構造）を組み立てる  |
| 実行      | 実際にデータベースが処理を行う    |

#### オプティマイザ
MySQLがクエリを受け取った後に 「最も効率の良い実行計画」 を決める仕組み
```
EXPLAIN SELECT * FROM users WHERE age > 20;
```
このコマンドを使えば、実行計画を見ることができる
以下は例
- 使用されたインデックス
- 行数の見積もり
- 結合方法
- 処理順序

#### 並行性の制御
複数のトランザクションが同時に動いても、データの整合性や正しさを守るための仕組み
常にリソースへの書き込みを行うクライアントを1つだけにし、クライアントの書き込み中は全てのより見取りを阻止するのが勇逸安全なポリシー
ロックがリソースを消費する
ロックの取得、ロックが空いてるかどうかのチェック、ロックの解除を含め、どのロック操作にもオーバーヘッドが伴う

#### オーバーヘッド
本来の目的以外にかかる余分なコストや処理のこと
DB関連だと以下のような場合、オーバーヘッドが発生しやすい
テーブルロック → 行ロックより簡単だが、他の人を全部待たせる → 並列性が悪化
複雑なクエリ → JOINが多い、サブクエリが深い → CPU・メモリのオーバーヘッドが大きくなる

#### ロック戦略
ロックのオーバーヘッドとデータの安全性に折り合いをつけることであり、どのように折り合いをつけるかがパフォーマンスを左右する。
MySQLのストレージエンジンは、独自のロックポリシーとロック粒度を実装可能

#### テーブルロック
テーブル単位でアクセスを制限するロックのこと
テーブルに対して読み書き自由、他の人は users テーブルに対して何もできない（読みも書きも不可）
オーバーヘッドは低い

#### 行ロック
テーブル全体ではなく、1行ごとにロックをかける仕組みのこと
オーバーヘッドが高い

#### トランザクション
複数の処理を1つのまとまりとして扱い、「全部成功するか、全部失敗するか」を保証する仕組み

#### ACIDテスト
| 性質      | もう少し詳しく               | 例                          |
| ------- | --------------------- | -------------------------- |
| 原子性 (A) | 処理は全部成功か全部失敗のどちらか     | 途中でエラーが起きたら、すべての変更を戻す      |
| 一貫性 (C) | トランザクション開始前後で整合性が保たれる | 口座残高がマイナスにならない、IDが重複しないなど  |
| 独立性 (I) | 他のトランザクションの中間状態は見えない  | 他のトランザクションの途中の変更を読めない      |
| 永続性 (D) | コミットしたら変更は永遠に保存される    | システムクラッシュ後もコミット済みデータは失われない |

#### ダーティリード
まだ確定（COMMIT）されていない他人の変更内容を読んでしまうこと
READ UNCOMMITTED	

#### ノンリピータブルリード
同じクエリを1つのトランザクション内で2回実行したとき、結果が変わってしまう現象
トランザクションAは一貫した状態で処理したいのに、途中で他の人に書き換えられてしまう
データの一貫性が崩れるリスクがある

#### ファっんトムリード
同じ検索条件で2回クエリを実行したとき、結果に「新しい行が増えたり減ったり」する現象
例）トランザクションAが同じ検索条件で2回クエリを実行した際、間にトランザクションBが該当条件に一致する新しい行を追加・コミットしたため、2回目の結果に最初は存在しなかった行が現れる現象をファントムリードという。

#### デッドロック
複数のトランザクションが互いに相手のロックを待ち続けることで、処理が停止する状態

#### トラインザクションログ
ディスク上で管理されるため、永続性あり

#### InnoDB
安定・高性能なトランザクション管理	
特徴：
- トランザクション対応（ACID）
- 行ロックによる高い並行性能
- クラッシュリカバリ機能あり
- 外部キー制約をサポート

#### NDB Cluster
分散型ストレージエンジン
高可用性・冗長構成・分散データ処理
特徴：
- データを複数ノードに自動分散・冗長化
- 高可用性（1台障害でも動き続ける）
- メモリベース処理中心で高速（ただし制約あり）
- リアルタイム性や自動フェイルオーバー重視

#### ASNI規格の4つの分離レベル
| 分離レベル                   | 主な特徴                           | 発生しうる現象                      |
| ----------------------- | ------------------------------ | ---------------------------- |
| **1. READ UNCOMMITTED** | 他の未確定な変更（未コミット）も読める            | ダーティリード、ノンリピータブルリード、ファントムリード |
| **2. READ COMMITTED**   | コミット済みの変更のみ読める                 | ノンリピータブルリード、ファントムリード         |
| **3. REPEATABLE READ**  | 同じ行の読み取り結果が常に同じ（ロック保持）         | ファントムリード（MySQLでは発生する）        |
| **4. SERIALIZABLE**     | すべてのトランザクションが**直列化されたかのように実行** | すべての現象を防止できる                 |

#### Lock Tables
明示的にロックをかけるSQL文

#### MVCC（Multi-Version Concurrency Control：多版同時実行制御）
各トランザクションが同時に処理しても互いに干渉しないよう、データの「スナップショット（過去バージョン）」を使って整合性を保つ仕組み
MySQL（特にInnoDB）で使われている高性能な並行処理制御の仕組み
